package com.example.swiftcheckin;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.view.View;
import android.widget.ImageView;

import androidx.core.content.ContextCompat;
import androidx.test.espresso.matcher.BoundedMatcher;
import androidx.test.ext.junit.rules.ActivityScenarioRule;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import static androidx.test.InstrumentationRegistry.getTargetContext;
import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
import static androidx.test.espresso.matcher.ViewMatchers.withText;
import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
import static androidx.test.espresso.Espresso.onView;
import static androidx.test.espresso.Espresso.onData;
import static androidx.test.espresso.matcher.ViewMatchers.withId;
import static androidx.test.espresso.assertion.ViewAssertions.matches;
import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
import static androidx.test.espresso.action.ViewActions.click;
import static org.hamcrest.Matchers.anything;

@RunWith(AndroidJUnit4.class)
public class ProfilePicTests {

    @Rule
    public ActivityScenarioRule<ProfileActivity> scenario = new
            ActivityScenarioRule<>(ProfileActivity.class);

    @Before
    public void setUp() {
        // Grant permission to avoid manually granting it during the test
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            getInstrumentation().getUiAutomation().executeShellCommand(
                    "pm grant " + getTargetContext().getPackageName()
                            + " android.permission.WRITE_EXTERNAL_STORAGE");
            getInstrumentation().getUiAutomation().executeShellCommand(
                    "pm grant " + getTargetContext().getPackageName()
                            + " android.permission.CAMERA");
        }
    }

    // Test uploading a profile picture.
    @Test
    public void testProfilePicUpload() {
        // Click on edit photo button
        onView(withId(R.id.edit_photo_button)).perform(click());

        // Select the first option which should be 'Choose from Gallery' or 'Take Photo' depending on your implementation
        onView(withText("Choose from Gallery")).perform(click());

        // NOTE: Espresso cannot interact with the Gallery app or camera directly.
        // You need to use an Intent Stubbing library like 'IntentsTestRule' or 'intending' from Espresso.
    }

    // Test removing a profile picture.
    @Test
    public void testProfilePicRemove() {
        // Click on remove photo button
        onView(withId(R.id.removeButton)).perform(click());

        // Verify that the default avatar is displayed
        onView(withId(R.id.avatarImage)).check(matches(isImageViewHasDrawable()));
        // Note: 'isImageViewHasDrawable()' needs to be a custom matcher defined to check if ImageView has a drawable.
    }

    // Test generating an avatar when there is no profile image.
    @Test
    public void testAvatarGenerated() {
        // Assuming that the avatar is generated by default when there is no profile image
        onView(withId(R.id.avatarImage)).check(matches(isImageViewHasDrawable()));
        // Note: This will pass if the image view always has a drawable (a generated avatar or uploaded picture).
        // You might want to refine this test to distinguish between a default avatar and a user-uploaded image.
    }

    // Custom matcher to check if ImageView has a drawable
    public static Matcher<View> isImageViewHasDrawable() {
        return new TypeSafeMatcher<View>() {
            @Override
            public boolean matchesSafely(View view) {
                return ((ImageView) view).getDrawable() != null;
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("ImageView should have a drawable set");
            }
        };
    }

    // Custom matcher to check for specific drawable resource in ImageView
    public static Matcher<View> withDrawable(final int resourceId) {
        return new BoundedMatcher<View, ImageView>(ImageView.class) {
            @Override
            protected boolean matchesSafely(ImageView imageView) {
                return sameBitmap(imageView.getContext(), imageView.getDrawable(), resourceId);
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("has drawable with resource id: ").appendValue(resourceId);
            }
        };
    }

    private static boolean sameBitmap(Context context, Drawable drawable, int resourceId) {
        Drawable otherDrawable = ContextCompat.getDrawable(context, resourceId);
        if (drawable == null || otherDrawable == null) {
            return false;
        }

        Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();
        Bitmap otherBitmap = ((BitmapDrawable) otherDrawable).getBitmap();
        return bitmap.sameAs(otherBitmap);
    }

    // Custom matcher to check for specific drawable in ImageView
    public static Matcher<View> withDrawable(final Drawable drawable) {
        return new BoundedMatcher<View, ImageView>(ImageView.class) {
            @Override
            protected boolean matchesSafely(ImageView imageView) {
                return sameBitmap(imageView.getContext(), imageView.getDrawable(), drawable);
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("has drawable: ").appendValue(drawable);
            }
        };
    }
}
